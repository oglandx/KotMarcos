\include{settings}

\begin{document}	% начало документа

\include{titlepage}



% Содержание
\tableofcontents

\newpage


\section{Введение}

Со времени появления первых языков программирования технологии написания программ постоянно совершенствуются. Язык программирования высокого уровня является средством описания задачи в терминах, близких как человеку, так и вычислительному устройству, на котором будет исполняться программа. За годы своего развития языки приобрели большое число конструкций, удобных для использования программистом в рассуждениях, а также упрощающих и ускоряющих написание и анализ программного кода.

Одним из препятствий, осложняющих написание понятного и лаконичного кода, является его дублирование. Языки программирования предоставляют следующие концепции, позволяющие частично решать данную проблему:

\begin{itemize}
\item Использование функций -- наиболее распространённая концепция, реализованная в большинстве Тьюринг-полных языков
\item Модульность на уровне файлов подразумевает возможность использовать один и тот же модуль (в виде исходного кода, либо прекомпилированный) повторно. Реализована в большинстве языков, независимо от используемых парадигм
\item Использование функций как объектов первого класса - подход функционального программирования, позволяющий параметризовать участки кода. Он заключается в возможности определять функции как значения и передавать их в качестве параметра
\item Наследование -- концепция объектно-ориентированного программирования, позволяющая использовать код базового класса в классе-потомке
\end{itemize}

Приведённые концепции позволяют абстрагировать и локализовать повторяющиеся участки кода. Однако существуют случаи, когда с использованием средств языка программирования не представляется возможным достичь простоты и элегантности решения. В этом случае прибегают к использованию средств, выходящих за его рамки и производящих препроцессирование исходного кода, результатом которого является создание программ. Такой подход называется метапрограммированием, а одним из наиболее распространённых средств данного подхода являются макрорасширения.



%\section{Проблема терминологии}
% ниже написана хуета какая-то
%
%Существует множество слов, начинающихся с префикса <<макро>> и используемых в похожих контекстах. Это и <<макроопределение>>, и <<макрокоманда>>, и <<макроинструкция>>, и <<макроподстановка>>, и <<макрорасширение>> и просто -- <<макрос>>. Слово происходит из английского языка от слова <<macro>>, являющегося сокращением от <<macroinstruction>>. На русский язык это можно перевести, как <<макроинструкция>> или <<макрокоманда>>. 
%
%В свою очередь, если углубиться в контекст задачи, в тексте программы присутствуют два типа макрорасширения языка -- описание и использование. Для первого случая наиболее близким по смыслу является слово <<макроопределение>>, а для второго -- <<макроподстановка>>. Обобщающими для обоих типов будем считать термины <<макрокоманда>>, <<макроинструкция>> или просто <<макро>>. Также часто используется слово <<макрос>>, являющееся транслитерацией множественного числа английского термина, в русском языке использующееся для обозначения единственного числа слова.

\newpage
\section{Макрорасширения в языках программирования}

\subsection{Макрорасширения императивных языков}

Первыми языками программирования ЭВМ были ассемблеры. Программа, написанная на таком языке, представляет собой последовательность символьных инструкций и их параметров, в результате преобразуемая компилятором в последовательность соответствующих машинных инструкций. То есть, по сути, изначально структурные различия между программой на ассемблере и аналогичной последовательностью инструкций в машинных кодах практически отсутствуют. Такое представление программ неудобно для восприятия человеком, так как влечёт за собой огромный разрыв между семантикой языка и семантикой описываемой на нём задачи. Неудивительно, что в скором времени стали появляться идеи по уменьшению такого семантического разрыва, и впоследствии появились первые средства для этого -- макрокоманды (или макроинструкции) для ассемблеров.

\textit{Макро}инструкции представляют собой параметризуемую последовательность \textit{микро}инструкций ассемблера, то есть ассемблерных команд. За счёт параметризуемости появляется новый уровень абстракции, способный упростить написание программ, упрощая их понимание и анализ для людей. Идея макроинструкций для ассемблеров получила широкое распространение в конце 50-х годов 20 века, предлагались различные концепции\cite{share_709_system}. Наиболее современный вид макро для ассемблера впервые был предложен Дугласом Макилроем (Douglas McIlroy) в 1959 году\cite{McIlroy:1960:MIE:367177.367223}.

Впоследствии подход, подобный подходу для описания макрокоманд ассемблера, был реализован в языке C\cite{c_preprocessor_macros}. Макрорасширение встроено в препроцессор языка, который, в сумме, предоставляет некоторые приёмы метапрограммирования, такие как простейшая кодогенерация и условная компиляция. 

Макро могут использоваться как объекты (object-like) и как функции (function-like). Причём большой проблемой является то, что макро из основного языка для программиста выглядят так же, как переменные или функции, что может повлечь случайное присвоение значения макро или случайный вызов функционального макро вместо функции с таким же именем. Для разрешения подобных проблем в языке C принято определять макро большими буквами.

В действительности, язык макро для языка C полностью отделён от основного языка, что влечёт за собой проблемы, связанные с \textit{гигиеной}, о чём будет сказано позже, а также отсутствием возможностей интраспекции и, как следствие, большими ограничениями в применении его как серьёзного средства метапрограммирования.

Языки-последователи языка C практически без изменений унаследовали от него препроцессор, в том числе и макрорасширение. Как результат, в языках Objective C, C++ и некоторых других могут возникнуть такие же серьёзные проблемы при использовании макро, как это происходит с языком C. С другой стороны, отсутствие изменений в макрорасширениях можно объяснить снижением необходимости в использовании препроцессора: в более высокоуровневых языках появились полноценные константные типы, шаблоны в C++ и дженерики (generics) в Objective C, а также другие конструкции основного языка, которые значительно ограничивают область применения препроцессора.

\subsection{Макрорасширения для декларативных языков}

С появлением в 1958 году языка Lisp, исторически второго языка высокого уровня после FORTRAN'а, начала своё развитие функциональная прадигма программирования. Именно на её базе родились концепции макрорасширений, которые будут рассмотрены далее. Первые макрорасширения для языка Lisp появились в 1963 году\cite{Steele:1993:EL:155360.155373}. Со временем Lisp приобрёл свои диалекты, распространённые в наши дни - Scheme (середина 70-х годов), Common Lisp (1984 год) и наиболее молодой язык Clojure (2007 год). Далее, в качестве реализации языка с LISP-подобным синтаксисом, будет рассматриваться язык Scheme, потому что именно для него велась большая часть исследований в области макрорасширений функциональных языков.

Lisp-подобные языки, в частности и язык Scheme, имеют очень простой синтаксис, отражающий одну из основных концепций языка -- \textit{гомоиконность}, то есть единое представление кода и данных. Общий вид любой структуры данных языка, в том числе и являющихся синтаксическими конструкциями (S-выражения), представляет список:

\begin{lstlisting}
	(cmd-or-fun param1 ... paramN)
\end{lstlisting}

Причём, как и полагается функциональному языку, функции в нём являются объектами первого класса, то есть работа с ними осуществляется так же, как с переменными. В частности, функция может быть передана в другую функцию в качестве параметра. Кроме функций, язык позволяет использовать операторы ветвления и мультиветвления, а циклы заменяются рекурсией.

Ветвление не может быть заменено на функции, так как в случае использования условного оператора вычисление должно производиться только по одной ветви, а при использовании функций, независимо от истинности заданного в условии предиката, будут выполнены обе ветви\cite{Abelson:1996:SIC:547755}. То же самое касается и условных операторов -- логических <<И>> (AND) и <<ИЛИ>> (OR): в случае <<ИЛИ>>, при условии истинности первого предиката, результат остальных неважен, как неважен для <<И>> результат вычисления предикатов, кроме первого, при условии его ложности.

Несмотря на невозможность определения подобных конструкций с помощью функций, в LISP-подобных языках, в том числе и в Scheme, есть средство абстракции более высокого уровня, позволяющее сделать это -- макрорасширения. Таким образом, появляется возможность введения в язык новых синтаксических конструкций, которые ограничиваются лишь базовым представлением конструкций языка.

Простой синтаксис, позволяющий написать интерпретатор языка за весьма короткое время, является одной из основных причин, почему язык так популярен для исследований, в том числе, для макрорасширений.

\newpage
\section{Концепции макрорасширений}

Как было сказано выше, именно в языке Scheme были впервые реализованы многие концепции, используемые впоследствии в реализациях макрорасширений для многих языков программирования. Ниже рассмотрены те из них, которые представляются наиболее интересными при реализации и полезными для применения в практике программирования.

\subsection{Macro-by-Example}

Концепция Macro-by-Example (<<макро по примеру>>, MBE) была описана в статье Е.Колбекера (Eugene Kohlbecker) в 1987 году\cite{Kohlbecker:1987:MDS:41625.41632}, где утверждается, что данный механизм используется в различных версиях языка Scheme с 1982 года, однако не был ранее описан. Приведённая спецификация макрорасширения предлагает использовать более декларативный подход к определению макро, чем традиционный, с помощью конструкций итерации и сопоставления.

Язык определения макро, включающий MBE, включает в себя входную и выходную спецификацию кода. Этот язык имеет следующие особенности:

\begin{itemize}
\item Для конкретизации определения макро введён механизм сопоставления по шаблону (pattern-matching), включающий проверку ошибок, осуществляемую на входе
\item Выходная спецификация соответствует форме выхода
\item Повторения определяются естественным образом как для входной, так и для выходной спецификаций
\end{itemize}

Процессирование такого макроопределения производится в два этапа: проход (staging) и представление (representation). Анализ, производимый на первом этапе, показывает, что возможно использование набора тестов, селекторов и конструкторов во время макроподстановки. Второй этап включает в себя поиск подходящего представления для функций.


Общий вид можно представить следующим образом:

\begin{lstlisting}[language=lisp]
(declare-syntax <name-of-macro> [(<input 1>) <output1>] [(<input2>) <output2>] ...)
\end{lstlisting}

В результате, к примеру, чтобы определить операцию логического умножения, необходимо написать следующее макроопределение:

\begin{lstlisting}[language=lisp]
(declare-syntax and
	[(and) true]
	[(and e) e]
	[(and e1 e2 ...) (if e1 (and e2 ...) false)])
\end{lstlisting}

Такой код позволяет простыми средствами определить безопасные конструкции, позволяющие, в том числе, расширить синтаксис базового языка.


\subsection{Гигиена}

Как было указано выше, макро в языке C имеют ряд проблем, прежде всего, связанных со способом процессирования таких макро\cite{Kernighan:1978:CPL:7519}. Макроподстановка осуществляется <<в лоб>>, игнорируя синтаксическую идентичность между вызовами макро и функций или обращению к переменным. Таким образом, неправильный способ именования макро может привести к неочевидным конфликтам имён. Такие конфликты иногда очень трудно разрешить. Можно допустить и другую ситуацию: предположим, что макроопределение объявлено в локальной области видимости. Так как областей видимости для макро нет, то мы можем запросто вызвать макро в совершенно другой области видимости, что приведёт к ошибке.

Ситуация осложняется ещё сильнее в случае, когда в макроопределении используются переменные. Ничто не запрещает в макроопределениях языка C объявлять переменные. Но также нет никакой проверки наличия переменной с таким же именем в области вызова макро! Таким образом, переменная, объявленная до вызова макро, может быть изменена. Ниже приведены фрагменты кода на языке C, иллюстрирующие данную проблему.


К примеру, если мы хотим посчитать дискримнинант для квадратного уравнения, можем определить следующий макро\cite{Clinger:1991:MW:99583.99607}.

\begin{lstlisting}[language=C]
#define discriminant(a, b, c) b*b - 4*a*c
\end{lstlisting}

В некоторых случаях это будет работать. Однако несложно привести пример кода, для которого макроподстановка будет осуществлена совсем не так, как этого может ожидать программист. К примеру, код ниже иллюстрирует, что может произойти, когда 

\begin{lstlisting}[language=C]
// подстановка произойдёт правильно

10*discriminant(42, x, y)

// подстановка произойдёт неправильно
2*discriminant(x - y, x + y, x - y)*5
\end{lstlisting}

Всему виной отсутствие восприятия передаваемых параметров как целостных объектов парсера: они подставляются <<как есть>>. В результате, во втором случае, вместо ожидаемого

\textbf{2*(x + y)*(x + y) - 4*(x - y)*(x - y)}

получим

\textbf{2*x + y*x + y - 4*x - y*x - y*5}.

Как и в случае разграничения именования объектов языка и макро, в данном случае могут помочь простые решения, такие как, например, обрамление скобками всех параметров макроопределения. Иллюстрирующий такой подход код приведён ниже.

\begin{lstlisting}[language=C]
#define discriminant(a, b, c) ((b)*(b) - 4*(a)*(c))

// подстановка произойдёт правильно
2*discriminant(x - y, x + y, x - y)*5
// получим 2*((x + y)*(x + y) - 4*(x - y)*(x - y))*5
\end{lstlisting}

Есть и довольно странные вещи, связанные с использованием макро. К примеру, такой код будет работать:

\begin{lstlisting}[language=C]
#define foo "salad
printf(foo bar")
\end{lstlisting}

Таким образом, макро в языке C позволяют писать абсолютно неправильные синтаксические конструкции.

Аналогичные проблемы существуют не только для макро языка C и позволяют понять, почему для макрорасширений важно свойство гигиены. Столкнулись с ними впервые ещё во времена, когда макрорасширения для языка Lisp только появлялись\cite{Skalski:2005}.

Свойство гигиены определяет, что переменные, определённые внутри макро, никогда не будут иметь конфликты с переменными, объявленными в области, где будет происходить раскрытие макро. Иными словами, пространство имён, определённое внутри макро, не должно пересекаться с пространством имён области, где будет произведена макроподстановка. Таким образом, наилучшим случаем будет являться гарантия, что любая переменная, объявленная внутри макроопределения, будет иметь уникальное имя при каждом его раскрытии.

Впервые гигиена была реализована и формально описана в 1986 году для языка Scheme\cite{Kohlbecker:1986:HME:319838.319859}. Реализовать гигиену можно по-разному. Например, в реализации гигиены для языка Nemerle используется цветовое кодирование\cite{Skalski:2005}. Каждый идентификатор внутри макро описывается как Ref(v, c, g), где v -- имя идентификатора, c -- цвет, а g -- глобальное окружение. Цвет уникален для каждого раскрытия макро.

Существуют также другие подходы к реализации макрорасширений, обладающих свойством гигиены\cite{Abelson:1996:SIC:547755}\cite{Herman:2010:TTH:1925552}\cite{clinger91hygienic}.

\subsection{Квазицитирование}

Гигиенические макрорасширения позволяют не задумываться об именах переменных, гарантируя, что сгенерированное имя точно будет уникальным и конфликтов не возникнет. Однако есть и обратная сторона медали. В случае, если внутри макроопределения необходим доступ к некоторой части кода, у программиста нет никаких способов сделать это, потому что любое имя переменной, объявленное внутри макро, будет изменено.

Квазицитирование реализовано в некоторых языках, например, Lisp\cite{Bawden1999}, Nemerle\cite{Skalski:2005},  Scala\cite{EPFL-REPORT-185242}.


\newpage
\section{Макрорасширения в многопрадигменных ЯП}


\subsection{Реализация макросов в языке Rust}


\subsection{Реализации макросов в языке Nemerle}

\newpage
\section{Необходимость макросов в языке Kotlin}

\newpage
\section{Возможные подходы к реализации макросов в языке Kotlin}

\newpage

\section{Заключение}

\newpage
\bibliographystyle{plain}
\bibliography{liter.bib}

\end{document}
